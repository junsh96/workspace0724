/*
    <VIEW 뷰>
    
    자주사용하는 SELECT 문을 하나의 가상테이블로 저장해놓은 객체
    실제 데이터를 저장하지 않고, SELECT문을 저장하여 조회.
    복잡한 조인 쿼리를 매번 작성하지 않고 간단하게 사용 가능.

*/

--한국에서 근무하는 사원들의 사번 이름 부서명 급여 근무국가 조회
SELECT EMP_ID,EMP_NAME,DEPT_TITLE,SALARY,NATIONAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT
ON DEPT_CODE = DEPT_ID
JOIN LOCATION
ON LOCAL_CODE = LOCATION_ID
JOIN NATIONAL USING(NATIONAL_CODE)
WHERE NATIONAL_NAME = '한국';

/*
    1. VIEW 생성방법
    
    CREATE VIEW 뷰명
    AS 서브쿼리
*/

GRANT CREATE VIEW TO C##SERVER;

CREATE VIEW VW_EMPLOYEE
AS (SELECT EMP_ID,EMP_NAME,DEPT_TITLE,SALARY,NATIONAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT
ON DEPT_CODE = DEPT_ID
JOIN LOCATION
ON LOCAL_CODE = LOCATION_ID
JOIN NATIONAL USING(NATIONAL_CODE));

SELECT *
FROM (SELECT EMP_ID,EMP_NAME,DEPT_TITLE,SALARY,NATIONAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT
ON DEPT_CODE = DEPT_ID
JOIN LOCATION
ON LOCAL_CODE = LOCATION_ID
JOIN NATIONAL USING(NATIONAL_CODE));

-- 뷰 호출
-- 실제로 실행되는것은 서브쿼리(인라인)로 실행.
SELECT * FROM VW_EMPLOYEE;

--한국에서 근무하는 사원들의 사번 이름 부서명 급여 근무국가 조회

SELECT * FROM VW_EMPLOYEE
WHERE NATIONAL_NAME = '한국';

--CREATE OR REPLACE VIEW VW_EMPLOYEE
-- VIEW가 없으면 생성 있으면 수정
CREATE OR REPLACE VIEW VW_EMPLOYEE
AS (SELECT EMP_ID,EMP_NAME,DEPT_TITLE,SALARY,NATIONAL_NAME,BONUS
FROM EMPLOYEE
JOIN DEPARTMENT
ON DEPT_CODE = DEPT_ID
JOIN LOCATION
ON LOCAL_CODE = LOCATION_ID
JOIN NATIONAL USING(NATIONAL_CODE));

/*
    뷰컬럼에 연산식, 함수식이 있는경우 무조건 별칭 지정.
*/

CREATE OR REPLACE VIEW VW_EMP_JOB
AS (SELECT EMP_ID,EMP_NAME,JOB_NAME,
        DECODE(SUBSTR(EMP_NO,8,1),1,'남',2,'여') AS "GENDER",
        EXTRACT(YEAR FROM SYSDATE)-EXTRACT(YEAR FROM HIRE_DATE) AS "SERVICEYEAR"
        FROM EMPLOYEE
        JOIN JOB USING(JOB_CODE));
        
SELECT * FROM VW_EMP_JOB;

SELECT * FROM VW_EMP_JOB WHERE SERVICEYEAR >= 20;

DROP VIEW VW_EMP_JOB;

----생성된 뷰를 통해서 (INSERT,UPDATE,DELETE) 사용가능
--- 이경우 실제 테이블의 데이터가 변경.

CREATE OR REPLACE VIEW VW_JOB
AS (SELECT JOB_CODE,JOB_NAME
    FROM JOB); 
    
SELECT * FROM VW_JOB;    

INSERT INTO VW_JOB
VALUES ('J8','인턴');


/*
    DML 명령어 사용이 불가한 경우
    1) 뷰에 없는 컬럼 조작
    2) 뷰에 정의되지 않은 컬럼중 NOT NULL 컬럼이 있는 경우
    3) 함수, 산술식을 사용한 경우
    4) 그룹함수나 GROUP BY절을 포함한 경우
    5) DISTINCT 구문이 포함된 경우
    6) JOIN을 이용해서 다중테이블을 설정한 경우
    
    대부분 뷰는 조회를 목적으로 사용한다.
*/

/*
    VIEW 생성 옵션
    
    [상세 표현식]
    CREATE [OR REPLACE] [FORCE | NOFORCE] VIEW 뷰명
    AS 서브쿼리
    [WITH CHECK POINT]
    [WITH READ ONLY]
    
    FORCE | NOFORCE
    >FORCE: 뷰 정의시 참조 테이블이 없어도 뷰 생성 가능
    >NOFORCE : 서브쿼리에 기술된 테이블이 존재할때만 생성.
    
    >WITH CHECK OPTION > 뷰의 WHERE 조건을 강제하여 조건에 맞는 데이터만 삽입/수정가능하게 함
    >WITH READ ONLY > 조회만 가능
*/

CREATE OR REPLACE NOFORCE VIEW VW_EMP
AS (SELECT TCODE,TNAME,TCONTENT FROM TT);

--서브 쿼리에 기술된 테이블이 존재하지 않아도 생성은 된다
CREATE OR REPLACE FORCE VIEW VW_EMP
AS (SELECT TCODE,TNAME,TCONENT FROM TT);

SELECT * FROM VW_EMP;


CREATE TABLE TT(
    TCODE NUMBER,
    TNAME VARCHAR2(20),
    TCONENT VARCHAR2(30)
);

-- VIEW CHECK POINT
CREATE OR REPLACE VIEW VW_EMP
AS (SELECT * FROM EMPLOYEE
        WHERE SALARY >= 3000000);
        
SELECT * FROM VW_EMP;

CREATE OR REPLACE VIEW VW_EMP
AS (SELECT * FROM EMPLOYEE
        WHERE SALARY >= 3000000)
WITH CHECK OPTION;

--뷰의 조건안에서 동작하도록 강제함
UPDATE VW_EMP
SET SALARY = 2000000
WHERE EMP_ID = '200';

CREATE OR REPLACE VIEW VW_EMP
AS (SELECT * FROM EMPLOYEE
        WHERE BONUS IS NOT NULL)
WITH READ ONLY;

UPDATE VW_EMP
SET SALARY = 2000000
WHERE EMP_ID = '200';
